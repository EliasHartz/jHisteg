package hartz.masterThesis.historyGuidedImpactAnalysis.core.changeComputation.traces.instrumentation.onTarget;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

/** Overwrites some functionality of ASM so that they are compatible with our own purposes... */
public class ClassWriterWithCustomLoader extends ClassWriter{

    private final ClassLoader loader;

    /**
     * Creates a custom asm class writer that uses a given class loader to obtain
     * referenced classes if necessary (e.g. if the instrumented class extends something)
     *
     * @param classReader the {@link org.objectweb.asm.ClassReader} used to read the original class. It
     *                    will be used to copy the entire constant pool from the
     *                    original class and also to copy other fragments of original
     *                    bytecode where applicable.
     * @param flags       option flags that can be used to modify the default behavior
     *                    of this class. <i>These option flags do not affect methods
     *                    that are copied as is in the new class. This means that the
     *                    maximum stack size nor the stack frames will be computed for
     *                    these methods</i>. See {@link #COMPUTE_MAXS},
     *                    {@link #COMPUTE_FRAMES}.
     * @param loader      Class loader used to obtain referenced classes
     */
    public ClassWriterWithCustomLoader(ClassReader classReader, int flags, ClassLoader loader) {
        super(classReader, flags);
        this.loader = loader;
    }

    /**
     * Creates a custom asm class writer that uses a given class loader to obtain
     * referenced classes if necessary (e.g. if the instrumented class extends something)
     *
     * @param flags  option flags that can be used to modify the default behavior
     *               of this class. See {@link #COMPUTE_MAXS},
     *               {@link #COMPUTE_FRAMES}.
     * @param loader class loader used to obtain referenced classes
     */
    public ClassWriterWithCustomLoader(int flags, ClassLoader loader) {
        super(flags);
        this.loader = loader;
    }

    /**
     * Returns the common super type of the two given types. The default
     * implementation of this method <i>loads</i> the two given classes and uses
     * the java.lang.Class methods to find the common super class. It can be
     * overridden to compute this common super type in other ways, in particular
     * without actually loading any class, or to take into account the class
     * that is currently being generated by this ClassWriter, which can of
     * course not be loaded since it is under construction.
     *
     * @param type1
     *            the internal name of a class.
     * @param type2
     *            the internal name of another class.
     * @return the internal name of the common super class of the two given
     *         classes.
     */
    protected String getCommonSuperClass(final String type1, final String type2) {
        Class<?> c, d;
        try {
            c = Class.forName(type1.replace('/', '.'), false, loader);
            d = Class.forName(type2.replace('/', '.'), false, loader);
        } catch (Exception e) {
            throw new RuntimeException(e.toString());
        }
        if (c.isAssignableFrom(d)) {
            return type1;
        }
        if (d.isAssignableFrom(c)) {
            return type2;
        }
        if (c.isInterface() || d.isInterface()) {
            return "java/lang/Object";
        } else {
            do {
                c = c.getSuperclass();
            } while (!c.isAssignableFrom(d));
            return c.getName().replace('.', '/');
        }
    }
}
